# 再帰ドリル(7)：メモ化

```haskell
fib :: Integer -> Integer
fib 0 = 0
fib 1 = 1
fib n = fib (n - 2) + fib (n - 1)
```

```haskell
> :set +s
> fib 33
3524578
(9.52 secs, 935623016 bytes)
```

```haskell
memoFib :: Integer -> Integer
memoFib = undefined
    
fibF :: (Integer -> Integer) -> (Integer -> Integer)
fibF = undefined
```

```haskell
> memoFib 33
3524578
(0.00 secs, 0 bytes)
```

##カタラン数

以下が経路の総数を計算するコードであった。

```haskell
catalan :: Integer -> Integer
catalan n = cat n n

cat :: Integer -> Integer -> Integer
cat _ 0 = 1
cat m n
  | m == n    = cat m (n - 1)
  | otherwise = cat m (n - 1) + cat (m - 1) n
```

これをメモ化を使って高速にせよ。

```haskell
memoCatalan :: Integer -> Integer
memoCatalan = undefined

catF :: (Integer -> Integer -> Integer) -> (Integer -> Integer -> Integer)
catF = undefined
```

以下が二分木の総数を計算するコードであった。

```haskell
catalan2 :: Integer -> Integer
catalan2 0 = 1
catalan2 n = sum (zipWith (*) xs ys)
  where
    xs = map catalan2 [0 .. n - 1]
    ys = map catalan2 [n - 1, n - 2 .. 0]
```

これをメモ化を使って高速にせよ。

```haskell
memoCatalan2 :: Integer -> Integer
memoCatalan2 n = memoFix catalanF2 n

catalanF2 :: (Integer -> Integer) -> (Integer -> Integer)
catalanF2 = undefined
```

##コインの両替

以下がコインの両替を解くコードであった。

```haskell
coin :: Integer -> [Integer] -> Integer
coin 0 _      = 1
coin _ []     = 0
coin n ccs@(c:cs)
  | n < 0     = 0
  | otherwise = coin n cs + coin (n - c) ccs
```

これをメモ化を使って高速にせよ。

```haskell
memoCoin :: Integer -> [Integer] -> Integer
memoCoin = undefined

coinF :: (Integer -> [Integer] -> Integer) -> (Integer -> [Integer] -> Integer)
coinF = undefined
```
