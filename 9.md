# 再帰ドリル(9)：リストを生成する再帰

今回は、入力としてリストを取り、出力としてリストを返す関数を再帰で実現することを考える。これらの関数は、出力のリストによって大まかに二分できる。

- 入力のリストとは反対向きのリストを出力する
- 入力のリストと同じ向きのリストを出力する

## 逆向きのリスト

ここでは、逆向きのリストを生成する関数 my_reverse について考える。

```haskell
> my_reverse [1,2,3]
[3,2,1]
```

リストを扱う関数は、[再帰ドリル(8)](8.md)で説明した基本操作から実装できる。このドリルの趣旨としては、すべてを作っていくべきであるが、ここでは説明を簡単にするため連結(++)はすでに実装されているとしよう。

入力のリストとは反対向きのリストを出力する関数 my_reverse は、連結を使うと、以下のように素朴な再帰で実装できる。

```haskell
my_reverse :: [a] -> [a]
my_reverse []     = [] 
my_reverse (x:xs) = my_reverse xs ++ [x]
```

この関数の動作を考えてみよう。

```haskell
     my_reverse (1:2:3:[])
→   my_reverse (2:3:[]) ++ [1]
→  (my_reverse (3:[])   ++ [2]) ++ [1]
→ ((my_reverse []       ++ [3]) ++ [2]) ++ [1]
→ (([] ++ [3]) ++ [2]) ++ [1]
→ ([3] ++ [2]) ++ [1]
→ [3,2] ++ [1]
→ [3,2,1]
```

正確な議論は割愛するが、効率が悪そうであることは理解できるだろう。

逆向きのリストを生成する関数は、蓄積変数を使う末尾再帰と相性がよいことが知られている。my_reverse を末尾再帰の形に直した my_reverse_iter は、以下の通り。


```haskell
my_reverse_iter :: [a] -> [a]
my_reverse_iter as = iter as []
  where
    iter :: [a] -> [a] -> [a]
    iter []     ys = ys
    iter (x:xs) ys = iter xs (x:ys)
```

ローカル関数 iter の動作は次のようになる。

```haskell
   iter (1:2:3:[])        []
-> iter   (2:3:[])     (1:[])
-> iter     (3:[])   (2:1:[])
-> iter        []  (3:2:1:[]) 
```

入力のリストを先頭から順に取り出して、空リストに追加していけば、自ずと逆向きになると言う訳だ。

学んだこと：

- 入力のリストとは反対向きのリストを出力する関数は、蓄積変数を使う末尾再帰と相性がよい

## 同じ向きのリスト

同じ向きのリストを生成する関数の例として my_map を考える。my_map は、関数とリストを取り、リストのそれぞれの要素に関数を適用した新しいリストを出力する。

```haskell
> my_map (+1) [1,2,3]
[2,3,4]
```

この関数はどう実装すると効率がよいだろうか？ 仮に末尾再帰で実装してみる。ここでも話を簡単にするために reverse は、すでに定義されているとする。

```haskell
my_map_iter :: (a -> b) -> [a] -> [b]
my_map_iter g as = reverse (iter g as [])
  where
    iter _ []     acc = acc
    iter f (x:xs) acc = iter f xs (f x : acc)
```

この関数は、関数をそれぞれの要素に適用した逆向きのリストを一旦作り、さらに逆向きにすることで、入力と同じ向きに直す。

    [1,2,3]
    ↓ iter
    [4,3,2]
    ↓ reverse
    [2,3,1]

```haskell
my_map :: (a -> b) -> [a] -> [b]
my_map _ []     = []
my_map f (x:xs) = f x : my_map f xs
```

