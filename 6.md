# 再帰ドリル(6)：再帰のこころ

再帰のこころとは

- 一歩手前ができているとすると次はどうする？

だ。

階乗を思い出そう。

```haskell
fact 1 = 1
fact 2 = 1 * 2
fact 3 = 1 * 2 * 3
fact 4 = 1 * 2 * 3 * 4
fact 5 = 1 * 2 * 3 * 4 * 5
```

一歩手前ができているとすると次はどうする？

```haskell
fact 1 = 1
fact 2 = fact 1 * 2
fact 3 = fact 2 * 3
fact 4 = fact 3 * 4
fact 5 = fact 4 * 5
```

これを一般化するとどうなる？

```haskell
fact 1 = 1 -- 基底部
fact n = fact (n - 1) * n -- 再帰部
```

気を付けたいのは、再帰と終了条件との関係である。再帰を止めるには、再帰の際に終了条件に向かうようにしなければならない。階乗の再帰部では、n は 2 以上であり、終了条件は n == 1 であるから、再帰する際に n を小さくして行く必要がある。

再帰のこころを追加しておこう。

- もっとも簡単なケースを考察して、終了条件を書く
- 再帰の際は、引数が終了条件に向かうようにする

ここで再帰的かつ高速な累乗の実装を思い出そう。

```haskell
powerFast :: Int -> Int -> Int
powerFast _ 0 = 1
powerFast m n
  | odd n     = powerFast (m*m) (n `div` 2) * m
  | otherwise = powerFast (m*m) (n `div` 2)
```

終了条件は、第二引数が 0 のときである。再帰の際は、第二引数が n \`div\` 2 のように小さくなっていることが分かる。逆に終了に関係ない第一引数は、自由に使われている(大きくなって行く)。

##ループに対する再帰の利点

再帰がループに比べてよい点は以下の通り。

- 制御が木構造に制限されているので、理解しやすい。入り口が一つで、枝分かれして行き、末端の葉の部分で終了するか、自分か他の関数へジャンプする
- ジャンプの際に、引数がどう変化するのか明示的に示される
- 型検査のある言語では、末端の葉の部分で型検査の洗礼を受ける。これで多くの間違いが発見できる

##ループを超えた再帰

これまでに出てきた再帰は、簡単に末尾再帰の形に直せた。つまり、ループと同等であった。

簡単には末尾再帰の形に直せないとき、我々はループを超えた再帰の力に頼ることになる。ループを超えた再帰の力とは、スタックの自動管理である。正格評価では、戻って来る場所スタックにを積んで、関数を呼び出す。再帰は、関数呼び出しで使われるこのスタックの自動管理を存分に活用していると言える。

もちろん、ループでも自分でスタックを管理すれば、ループを超えた再帰と同じことはできる。しかし、それは煩雑で間違いを起こしやすい。

以下ではループを超えた再帰の力を使う問題を紹介する。これらの問題は、これまでの問題に比べると難しい。なぜなら、ループの範囲を超えているからだ。最初分からなくても、がっかりしないていただきたい。

以下で扱う問題は、ソフトウェアに力を入れている会社の面接で出題されることもあるので、何度も読み直して理解して欲しい。

##経路の数

n 掛ける n の升目状の道があって、左下の角(S)から右下の角(D)へ向かうとする。ただし、進めるのは右か上で、しかも対角線を横切ってはいけない。経路の総数はいくつあるか？

以下の図から分かるように n が 3 の場合、経路の総数は 5 である。

![経路の数](figs/routing.png?raw=true)

ここでしばらく問題を考えること！

では、解き方を説明する。

右方向に進んだ数を m、上方向に進んだ数を n とし、その地点への経路の総数を cat m n で表すとする。ここで m は n 以上であることに注意しよう。

![経路の数](figs/routing2.png?raw=true)

上の図から分かるように以下の二つに場合分けできる。

- m == n のとき：cat m n は cat m (n - 1) に等しい


```haskell
catalan :: Integer -> Integer
catalan n = cat n n

cat :: Integer -> Integer -> Integer
cat _ 0 = 1
cat m n
  | m == n    = undefined
  | otherwise = undefined
```

##二分木の数

ノードの数を n としたとき、二分木の形の総数(Nn で表す)はいくつあるか？

問題を理解するために、n が 1、2、3 のときを図示する。

![二分木の数](figs/tree.png?raw=true)

この図から分かるように

- N1 = 1
- N2 = 2
- N3 = 5

である。

ここでしばらく問題を考えること！

```haskell
catalan2 :: Integer -> Integer
catalan2 0 = 1
catalan2 n = sum (zipWith (*) xs ys)
  where
    xs = undefined
    ys = undefined
```

実は、「経路の数」と「二分木の数」は、カタラン数という同じ問題である。今回は、カタラン数を 2 種類の方法で解いたことになる。以下に、カタラン数が根底にある問題の一例を示す。

- 一泊 5,000 円のホテルがある。ここに 5,000 円を持った客 n 人と 10,000円を持った客 n 人を泊まらせたい。ホテルには受付開始時におつりが用意されてない。おつりが不足しないような客の来方は、何通りあるか？


##コインの両替

ここでしばらく問題を考えること！

```haskell
coin :: Integer -> [Integer] -> Integer
coin 0 _      = 1
coin _ []     = 0
coin n ccs@(c:cs)
  | n < 0     = 0
  | otherwise = undefined
```
