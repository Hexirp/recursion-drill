# 再帰ドリル(6)：再帰のこころ

再帰のこころとは

- 一歩手前ができているとすると次はどうする？

だ。

階乗を思い出そう。

```haskell
fact 1 = 1
fact 2 = 1 * 2
fact 3 = 1 * 2 * 3
fact 4 = 1 * 2 * 3 * 4
fact 5 = 1 * 2 * 3 * 4 * 5
```

一歩手前ができているとすると次はどうする？

```haskell
fact 1 = 1
fact 2 = fact 1 * 2
fact 3 = fact 2 * 3
fact 4 = fact 3 * 4
fact 5 = fact 4 * 5
```

これを一般化するとどうなる？

```haskell
fact 1 = 1 -- 基底部
fact n = fact (n - 1) * n -- 再帰部
```

一つ気を付けたいのは、再帰と終了条件との関係である。再帰を止めるには、再帰の際に終了条件に向かうように気をつけなければならない。

階乗の再帰部では、n は 2 以上であり、終了条件は n == 1 であるから、再帰する際に n を小さくして行く必要がある。

再帰のこころを追加しておこう。

- もっとも簡単なケースを考察して、終了条件を書く
- 再帰の際は、引数が終了条件に向かうようにする

ここで再帰的かつ高速な累乗の実装を思い出そう。

```haskell
powerFast :: Int -> Int -> Int
powerFast _ 0 = 1
powerFast m n
  | odd n     = powerFast (m*m) (n `div` 2) * m
  | otherwise = powerFast (m*m) (n `div` 2)
```

終了条件は、第二引数が 0 のときである。再帰の際は、第二引数が n `div` 2 のように小さくなっていることが分かる。逆に終了に関係ない第一引数は、自由に使われている(大きくなって行く)。

##ループに対する再帰の利点

再帰がループに比べてよい点は以下の通り。

- 制御が木構造に制限されているので、理解しやすい。入り口が一つで、枝分かれして行き、末端の葉の部分で終了するか、自分か他の関数へジャンプする
- ジャンプの際に、引数がどう変化するのか明示的に示される
- 型検査のある言語では、末端の葉の部分で型検査の洗礼を受ける。これで多くの間違いが発見できる

##ループを超えた再帰

これまでに出てきた再帰は、簡単に末尾再帰の形に直せた。つまり、ループと同等であった。

簡単には末尾再帰の形に直せないとき、我々はループを超えた再帰の力に頼ることになる。ループを超えた再帰の力とは、スタックの自動管理である。正格評価では、戻って来る場所スタックにを積んで、関数を呼び出す。再帰は、関数呼び出しで使われるこのスタックの自動管理を存分に活用していると言える。

もちろん、ループでも自分でスタックを管理すれば、ループを超えた再帰と同じことはできる。しかし、それは煩雑で間違いを起こしやすい。

以下ではループを超えた再帰の力を使う問題を紹介する。これらの問題は、これまでの問題に比べると難しい。なぜなら、ループの範囲を超えているからだ。最初分からなくても、がっかりしないていただきたい。

以下で扱う問題は、ソフトウェアに力を入れている会社の面接で出題されることもあるので、何度も読み直して理解して欲しい。

##経路の数

```haskell
catalan :: Integer -> Integer
catalan n = cat n n

cat :: Integer -> Integer -> Integer
cat _ 0 = 1
cat m n
  | m == n    = undefined
  | otherwise = undefined
```

##二分木の数

![二分木の数](https://raw.github.com/kazu-yamamoto/recursion-drill/master/figs/tree.png)

```haskell
catalan2 :: Integer -> Integer
catalan2 0 = 1
catalan2 n = sum (zipWith (*) xs ys)
  where
    xs = undefined
    ys = undefined
```

##コインの両替

```haskell
coin :: Integer -> [Integer] -> Integer
coin 0 _      = 1
coin _ []     = 0
coin n ccs@(c:cs)
  | n < 0     = 0
  | otherwise = undefined
```
