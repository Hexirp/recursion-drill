# 再帰ドリル(6)：再帰のこころ

再帰のこころとは

- 一歩手前ができているとすると次はどうする？

だ。

階乗を思い出そう。

```haskell
fact 1 = 1
fact 2 = 1 * 2
fact 3 = 1 * 2 * 3
fact 4 = 1 * 2 * 3 * 4
fact 5 = 1 * 2 * 3 * 4 * 5
```

一歩手前ができているとすると次はどうする？

```haskell
fact 1 = 1
fact 2 = fact 1 * 2
fact 3 = fact 2 * 3
fact 4 = fact 3 * 4
fact 5 = fact 4 * 5
```

これを一般化するとどうなる？

```haskell
fact 1 = 1 -- 基底部
fact n = fact (n - 1) * n -- 再帰部
```

一つ気を付けたいのは、再帰と終了条件との関係である。再帰を止めるには、再帰の際に終了条件に向かうように気をつけなければならない。

階乗の再帰部では、n は 2 以上であり、終了条件は n == 1 であるから、再帰する際に n を小さくして行く必要がある。

再帰のこころを追加しておこう。

- もっとも簡単なケースを考察して、終了条件を書く
- 再帰の際は、引数が終了条件に向かうようにする

ここで累乗の再帰的かつ高速な実装を思い出そう。

```haskell
powerFast :: Int -> Int -> Int
powerFast _ 0 = 1
powerFast m n
  | odd n     = powerFast (m*m) (n `div` 2) * m
  | otherwise = powerFast (m*m) (n `div` 2)
```

終了条件は、第二引数が 0 のときである。再帰の際は、n `div` 2 として、第二引数が小さくなっていることが分かる。逆に終了に関係ない第一引数は、自由に使われている(大きくなって行く)。

再帰がループに比べてよい点は以下の通り。

- 制御が木構造に制約されているので、理解しやすい。入り口が一つで、枝割れして行き、末端の葉の部分で終了するか、自分か他の関数へジャンプする
- ジャンプの際に、引数がどう変化するのか明示的に示される
- 型検査のある言語では、末端の葉の部分で型検査の洗礼を受ける。これで多くの間違いが発見できる

