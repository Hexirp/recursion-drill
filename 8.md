# 再帰ドリル(8)：リストに対する素朴な再帰

今回からリストに対する再帰を学ぶ。関数は、入力としてリストを取る。この種の再帰関数は、出力によって大まかに二分できる。

1. (リストではない)値を返す
2. リストを返す

今回は前者を対象とする。すなわち、入力としてリストを取り、値を返す再帰関数について学ぶ。

## Haskell のリスト

GHCi でリストに対する情報を表示させみよう。

```haskell
> :info []
data [] a = [] | a : [a]
```

なんだか分からない情報が表示された。これが分からないのは、表記が揺れていたり、記号を使っていたりするからだ。順にほぐしていこう。まず、角括弧で表現されている型の表記を統一する。

```haskell
data [] a = [] | a : [] a
```

そして、構成子を前に出す。(Haskell では、アルファベットの構成子の他に、":" から始まる二項演算子としての構成子が許されている。)

```haskell
data [] a = [] | (:) a ([] a)
```

最後に記号をアルファベットに変えてみる。

```haskell
data List a = Nil | Cons a (List a)
```

これを自然数の定義と比較してみよう。

```haskell
data Nat = Z | S Nat
```

List は値を格納している以外は、自然数と同じであることが分かる。自然数は再帰的に定義されているので、再帰処理と相性がよかった。同様に、リストも再帰的に定義されているので、再帰処理と相性がよいのである。

## 様式

リストの再帰的に処理する関数は、基本的に以下のような形を取る。

```haskell
my_foo []     = ... -- 基底部
my_foo (x:xs) = ... -- 再帰部
```

例として、リストの長さを測る関数 my_length を考えよう。

```haskell
my_length []        = 0
my_length [_]       = 0 + 1
my_length [_,_]     = 0 + 1 + 1
my_length [_,_,_]   = 0 + 1 + 1 + 1
my_length [_,_,_,_] = 0 + 1 + 1 + 1 + 1
```

一歩手前を使うとどうなる？

```haskell
my_length []        = 0
my_length [_]       = my_length []      + 1
my_length [_,_]     = my_length [_]     + 1
my_length [_,_,_]   = my_length [_,_]   + 1
my_length [_,_,_,_] = my_length [_,_,_] + 1
```

再帰部を一般化するとどうなる？

```haskell
my_length :: [a] -> Integer
my_length []     = 0
my_length (_:xs) = my_length xs + 1
```

つまり再帰部は、再帰のこころに従って以下のように考える。

- my_foo xs ができているとする。my_foo xs を使うと、my_foo (x:xs) はどうなる？

my_length xs の長さが分かっているとするなら、my_length (_:xs) の長さは、それに 1 を加えれば得られる。(x は利用しないので、捨てている。)

###演習

入力として Integer のリストを取り、要素すべてを足した結果を返す関数 my_sum を実装しなさい。

```haskell
my_sum :: [Integer] -> Integer
my_sum = undefined
```

入力として Integer のリストを取り、要素すべてを掛けた結果を返す関数 my_product を実装しなさい。

```haskell
my_product :: [Integer] -> Integer
my_product = undefined
```

##末尾再帰
