# 再帰ドリル(5)：自然数に対する少し複雑な再帰

今回学ぶ再帰は少し複雑だが、すべてループと同等である。

##最大公約数

最大公約数(GCD: greatest common divisor)は、中学校で習っただろう。そのアルゴリズムの要は、共通項を見つけることである。共通項を見つけるには、素因数分解しないといけない。素因数分解のためには、素数表を作成しないといけない。そして、大きな数が素数であるか判定するのは、かなり難しいし時間がかかる。よって、このアルゴリズムは現実的ではない。

最大公約数を算出する方法には、実はとても簡単な方法がある。なぜ中学校でこちらを教えないか不思議なくらいだ。2 より大きい自然数 a と b があって、a >= b とすると、最大公約数は、a - b で計算できる。ウソだと思うかもしれないので、実際に試してみよう。12 と 8 の最大公約数は 4 である。12 から 8 を引くと 4 になるから、最大公約数が求まっている。

その種明かしをしよう。a と b の最大公約数を G とし、a = G * A、b = G * B とおく。a - b = G (A - B) なので、引き算しても G は消えない。A - B の部分を 1 にできれば、G が求まるというわけだ。これを再帰で実装すると以下のようになる。

```haskell
gcdSlow :: Int -> Int -> Int
gcdSlow a 0 = a
gcdSlow a b
  | c >= b    = gcdSlow c b
  | otherwise = gcdSlow b c
  where
    c = a - b
```

gcdSlow は a >= b と仮定していることに注意。基底部がなぜ、こうなるのかは自分で考えること。

###演習

gcdSlow は何度も引き算をして、c >= b のときにはじめて引数をひっくり返した。何度も引いて、最後に小さくなるものとは、余りに他ならない。よって、余りを計算するようにすれば、この関数は劇的に速くなる。

問：余りを計算する演算子 mod を使って、gcdSlow を書き直し、gcdFast として定義せよ。

```haskell
gcdFast :: Int -> Int -> Int
gcdFast = undefined
```

###演習

問：最小公倍数(LCM: least common multiple) を求める関数 lcmFast を gcdFast を使って実装せよ。ただし、引数が任意の順序でよいように工夫せよ。

```haskell
lcmFast :: Int -> Int -> Int
lcmFast = undefined
```

###累乗

累乗を計算する関数 power を思い出そう。

```haskell
power m 1 = m
power m n = power m (n - 1) * m
```

この実装を n が 0 のときにも対応できるように、以下のように書き直す。

```haskell
power :: Int -> Int -> Int
power _ 0 = 1
power m n = power m (n - 1) * m
```

